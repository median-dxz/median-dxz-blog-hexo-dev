{"version":3,"file":"color-thief.umd.js","sources":["../node_modules/quantize/dist/index.mjs","../src/color-thief.js","../src/core.js"],"sourcesContent":["/*\n * quantize.js Copyright 2008 Nick Rabinowitz\n * Ported to node.js by Olivier Lesnicki\n * Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php\n */\n// fill out a couple protovis dependencies\n\n/*\n * Block below copied from Protovis: http://mbostock.github.com/protovis/\n * Copyright 2010 Stanford Visualization Group\n * Licensed under the BSD License: http://www.opensource.org/licenses/bsd-license.php\n */\nif (!pv) {\n  var pv = {\n    map: function (array, f) {\n      var o = {};\n      return f ? array.map(function (d, i) {\n        o.index = i;\n        return f.call(o, d);\n      }) : array.slice();\n    },\n    naturalOrder: function (a, b) {\n      return a < b ? -1 : a > b ? 1 : 0;\n    },\n    sum: function (array, f) {\n      var o = {};\n      return array.reduce(f ? function (p, d, i) {\n        o.index = i;\n        return p + f.call(o, d);\n      } : function (p, d) {\n        return p + d;\n      }, 0);\n    },\n    max: function (array, f) {\n      return Math.max.apply(null, f ? pv.map(array, f) : array);\n    }\n  };\n}\n/**\n * Basic Javascript port of the MMCQ (modified median cut quantization)\n * algorithm from the Leptonica library (http://www.leptonica.com/).\n * Returns a color map you can use to map original pixels to the reduced\n * palette. Still a work in progress.\n * \n * @author Nick Rabinowitz\n * @example\n \n// array of pixels as [R,G,B] arrays\nvar myPixels = [[190,197,190], [202,204,200], [207,214,210], [211,214,211], [205,207,207]\n                // etc\n                ];\nvar maxColors = 4;\n \nvar cmap = MMCQ.quantize(myPixels, maxColors);\nvar newPalette = cmap.palette();\nvar newPixels = myPixels.map(function(p) { \n    return cmap.map(p); \n});\n \n */\n\n\nvar MMCQ = function () {\n  // private constants\n  var sigbits = 5,\n      rshift = 8 - sigbits,\n      maxIterations = 1000,\n      fractByPopulations = 0.75; // get reduced-space color index for a pixel\n\n  function getColorIndex(r, g, b) {\n    return (r << 2 * sigbits) + (g << sigbits) + b;\n  } // Simple priority queue\n\n\n  function PQueue(comparator) {\n    var contents = [],\n        sorted = false;\n\n    function sort() {\n      contents.sort(comparator);\n      sorted = true;\n    }\n\n    return {\n      push: function (o) {\n        contents.push(o);\n        sorted = false;\n      },\n      peek: function (index) {\n        if (!sorted) { sort(); }\n        if (index === undefined) { index = contents.length - 1; }\n        return contents[index];\n      },\n      pop: function () {\n        if (!sorted) { sort(); }\n        return contents.pop();\n      },\n      size: function () {\n        return contents.length;\n      },\n      map: function (f) {\n        return contents.map(f);\n      },\n      debug: function () {\n        if (!sorted) { sort(); }\n        return contents;\n      }\n    };\n  } // 3d color space box\n\n\n  function VBox(r1, r2, g1, g2, b1, b2, histo) {\n    var vbox = this;\n    vbox.r1 = r1;\n    vbox.r2 = r2;\n    vbox.g1 = g1;\n    vbox.g2 = g2;\n    vbox.b1 = b1;\n    vbox.b2 = b2;\n    vbox.histo = histo;\n  }\n\n  VBox.prototype = {\n    volume: function (force) {\n      var vbox = this;\n\n      if (!vbox._volume || force) {\n        vbox._volume = (vbox.r2 - vbox.r1 + 1) * (vbox.g2 - vbox.g1 + 1) * (vbox.b2 - vbox.b1 + 1);\n      }\n\n      return vbox._volume;\n    },\n    count: function (force) {\n      var vbox = this,\n          histo = vbox.histo;\n\n      if (!vbox._count_set || force) {\n        var npix = 0,\n            i,\n            j,\n            k,\n            index;\n\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              index = getColorIndex(i, j, k);\n              npix += histo[index] || 0;\n            }\n          }\n        }\n\n        vbox._count = npix;\n        vbox._count_set = true;\n      }\n\n      return vbox._count;\n    },\n    copy: function () {\n      var vbox = this;\n      return new VBox(vbox.r1, vbox.r2, vbox.g1, vbox.g2, vbox.b1, vbox.b2, vbox.histo);\n    },\n    avg: function (force) {\n      var vbox = this,\n          histo = vbox.histo;\n\n      if (!vbox._avg || force) {\n        var ntot = 0,\n            mult = 1 << 8 - sigbits,\n            rsum = 0,\n            gsum = 0,\n            bsum = 0,\n            hval,\n            i,\n            j,\n            k,\n            histoindex;\n\n        for (i = vbox.r1; i <= vbox.r2; i++) {\n          for (j = vbox.g1; j <= vbox.g2; j++) {\n            for (k = vbox.b1; k <= vbox.b2; k++) {\n              histoindex = getColorIndex(i, j, k);\n              hval = histo[histoindex] || 0;\n              ntot += hval;\n              rsum += hval * (i + 0.5) * mult;\n              gsum += hval * (j + 0.5) * mult;\n              bsum += hval * (k + 0.5) * mult;\n            }\n          }\n        }\n\n        if (ntot) {\n          vbox._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n        } else {\n          //console.log('empty box');\n          vbox._avg = [~~(mult * (vbox.r1 + vbox.r2 + 1) / 2), ~~(mult * (vbox.g1 + vbox.g2 + 1) / 2), ~~(mult * (vbox.b1 + vbox.b2 + 1) / 2)];\n        }\n      }\n\n      return vbox._avg;\n    },\n    contains: function (pixel) {\n      var vbox = this,\n          rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      return rval >= vbox.r1 && rval <= vbox.r2 && gval >= vbox.g1 && gval <= vbox.g2 && bval >= vbox.b1 && bval <= vbox.b2;\n    }\n  }; // Color map\n\n  function CMap() {\n    this.vboxes = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.vbox.count() * a.vbox.volume(), b.vbox.count() * b.vbox.volume());\n    });\n  }\n\n  CMap.prototype = {\n    push: function (vbox) {\n      this.vboxes.push({\n        vbox: vbox,\n        color: vbox.avg()\n      });\n    },\n    palette: function () {\n      return this.vboxes.map(function (vb) {\n        return vb.color;\n      });\n    },\n    size: function () {\n      return this.vboxes.size();\n    },\n    map: function (color) {\n      var vboxes = this.vboxes;\n\n      for (var i = 0; i < vboxes.size(); i++) {\n        if (vboxes.peek(i).vbox.contains(color)) {\n          return vboxes.peek(i).color;\n        }\n      }\n\n      return this.nearest(color);\n    },\n    nearest: function (color) {\n      var vboxes = this.vboxes,\n          d1,\n          d2,\n          pColor;\n\n      for (var i = 0; i < vboxes.size(); i++) {\n        d2 = Math.sqrt(Math.pow(color[0] - vboxes.peek(i).color[0], 2) + Math.pow(color[1] - vboxes.peek(i).color[1], 2) + Math.pow(color[2] - vboxes.peek(i).color[2], 2));\n\n        if (d2 < d1 || d1 === undefined) {\n          d1 = d2;\n          pColor = vboxes.peek(i).color;\n        }\n      }\n\n      return pColor;\n    },\n    forcebw: function () {\n      // XXX: won't  work yet\n      var vboxes = this.vboxes;\n      vboxes.sort(function (a, b) {\n        return pv.naturalOrder(pv.sum(a.color), pv.sum(b.color));\n      }); // force darkest color to black if everything < 5\n\n      var lowest = vboxes[0].color;\n      if (lowest[0] < 5 && lowest[1] < 5 && lowest[2] < 5) { vboxes[0].color = [0, 0, 0]; } // force lightest color to white if everything > 251\n\n      var idx = vboxes.length - 1,\n          highest = vboxes[idx].color;\n      if (highest[0] > 251 && highest[1] > 251 && highest[2] > 251) { vboxes[idx].color = [255, 255, 255]; }\n    }\n  }; // histo (1-d array, giving the number of pixels in\n  // each quantized region of color space), or null on error\n\n  function getHisto(pixels) {\n    var histosize = 1 << 3 * sigbits,\n        histo = new Array(histosize),\n        index,\n        rval,\n        gval,\n        bval;\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      index = getColorIndex(rval, gval, bval);\n      histo[index] = (histo[index] || 0) + 1;\n    });\n    return histo;\n  }\n\n  function vboxFromPixels(pixels, histo) {\n    var rmin = 1000000,\n        rmax = 0,\n        gmin = 1000000,\n        gmax = 0,\n        bmin = 1000000,\n        bmax = 0,\n        rval,\n        gval,\n        bval; // find min/max\n\n    pixels.forEach(function (pixel) {\n      rval = pixel[0] >> rshift;\n      gval = pixel[1] >> rshift;\n      bval = pixel[2] >> rshift;\n      if (rval < rmin) { rmin = rval; }else if (rval > rmax) { rmax = rval; }\n      if (gval < gmin) { gmin = gval; }else if (gval > gmax) { gmax = gval; }\n      if (bval < bmin) { bmin = bval; }else if (bval > bmax) { bmax = bval; }\n    });\n    return new VBox(rmin, rmax, gmin, gmax, bmin, bmax, histo);\n  }\n\n  function medianCutApply(histo, vbox) {\n    if (!vbox.count()) { return; }\n    var rw = vbox.r2 - vbox.r1 + 1,\n        gw = vbox.g2 - vbox.g1 + 1,\n        bw = vbox.b2 - vbox.b1 + 1,\n        maxw = pv.max([rw, gw, bw]); // only one pixel, no split\n\n    if (vbox.count() == 1) {\n      return [vbox.copy()];\n    }\n    /* Find the partial sum arrays along the selected axis. */\n\n\n    var total = 0,\n        partialsum = [],\n        lookaheadsum = [],\n        i,\n        j,\n        k,\n        sum,\n        index;\n\n    if (maxw == rw) {\n      for (i = vbox.r1; i <= vbox.r2; i++) {\n        sum = 0;\n\n        for (j = vbox.g1; j <= vbox.g2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(i, j, k);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else if (maxw == gw) {\n      for (i = vbox.g1; i <= vbox.g2; i++) {\n        sum = 0;\n\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.b1; k <= vbox.b2; k++) {\n            index = getColorIndex(j, i, k);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    } else {\n      /* maxw == bw */\n      for (i = vbox.b1; i <= vbox.b2; i++) {\n        sum = 0;\n\n        for (j = vbox.r1; j <= vbox.r2; j++) {\n          for (k = vbox.g1; k <= vbox.g2; k++) {\n            index = getColorIndex(j, k, i);\n            sum += histo[index] || 0;\n          }\n        }\n\n        total += sum;\n        partialsum[i] = total;\n      }\n    }\n\n    partialsum.forEach(function (d, i) {\n      lookaheadsum[i] = total - d;\n    });\n\n    function doCut(color) {\n      var dim1 = color + '1',\n          dim2 = color + '2',\n          left,\n          right,\n          vbox1,\n          vbox2,\n          d2,\n          count2 = 0;\n\n      for (i = vbox[dim1]; i <= vbox[dim2]; i++) {\n        if (partialsum[i] > total / 2) {\n          vbox1 = vbox.copy();\n          vbox2 = vbox.copy();\n          left = i - vbox[dim1];\n          right = vbox[dim2] - i;\n          if (left <= right) { d2 = Math.min(vbox[dim2] - 1, ~~(i + right / 2)); }else { d2 = Math.max(vbox[dim1], ~~(i - 1 - left / 2)); } // avoid 0-count boxes\n\n          while (!partialsum[d2]) { d2++; }\n\n          count2 = lookaheadsum[d2];\n\n          while (!count2 && partialsum[d2 - 1]) { count2 = lookaheadsum[--d2]; } // set dimensions\n\n\n          vbox1[dim2] = d2;\n          vbox2[dim1] = vbox1[dim2] + 1; // console.log('vbox counts:', vbox.count(), vbox1.count(), vbox2.count());\n\n          return [vbox1, vbox2];\n        }\n      }\n    } // determine the cut planes\n\n\n    return maxw == rw ? doCut('r') : maxw == gw ? doCut('g') : doCut('b');\n  }\n\n  function quantize(pixels, maxcolors) {\n    // short-circuit\n    if (!pixels.length || maxcolors < 2 || maxcolors > 256) {\n      // console.log('wrong number of maxcolors');\n      return false;\n    } // XXX: check color content and convert to grayscale if insufficient\n\n\n    var histo = getHisto(pixels);\n // check that we aren't below maxcolors already\n    histo.forEach(function () {\n    });\n    // get the beginning vbox from the colors\n\n\n    var vbox = vboxFromPixels(pixels, histo),\n        pq = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.count(), b.count());\n    });\n    pq.push(vbox); // inner function to do the iteration\n\n    function iter(lh, target) {\n      var ncolors = lh.size(),\n          niters = 0,\n          vbox;\n\n      while (niters < maxIterations) {\n        if (ncolors >= target) { return; }\n\n        if (niters++ > maxIterations) {\n          // console.log(\"infinite loop; perhaps too few pixels!\");\n          return;\n        }\n\n        vbox = lh.pop();\n\n        if (!vbox.count()) {\n          /* just put it back */\n          lh.push(vbox);\n          niters++;\n          continue;\n        } // do the cut\n\n\n        var vboxes = medianCutApply(histo, vbox),\n            vbox1 = vboxes[0],\n            vbox2 = vboxes[1];\n\n        if (!vbox1) {\n          // console.log(\"vbox1 not defined; shouldn't happen!\");\n          return;\n        }\n\n        lh.push(vbox1);\n\n        if (vbox2) {\n          /* vbox2 can be null */\n          lh.push(vbox2);\n          ncolors++;\n        }\n      }\n    } // first set of colors, sorted by population\n\n\n    iter(pq, fractByPopulations * maxcolors); // console.log(pq.size(), pq.debug().length, pq.debug().slice());\n    // Re-sort by the product of pixel occupancy times the size in color space.\n\n    var pq2 = new PQueue(function (a, b) {\n      return pv.naturalOrder(a.count() * a.volume(), b.count() * b.volume());\n    });\n\n    while (pq.size()) {\n      pq2.push(pq.pop());\n    } // next set - generate the median cuts using the (npix * vol) sorting.\n\n\n    iter(pq2, maxcolors); // calculate the actual colors\n\n    var cmap = new CMap();\n\n    while (pq2.size()) {\n      cmap.push(pq2.pop());\n    }\n\n    return cmap;\n  }\n\n  return {\n    quantize: quantize\n  };\n}();\n\nvar quantize = MMCQ.quantize;\n\nexport default quantize;\n","import quantize from '../node_modules/quantize/dist/index.mjs';\nimport core from './core.js';\n\n/*\n * Color Thief v2.2.0\n * by Lokesh Dhakar - http://www.lokeshdhakar.com\n *\n * Thanks\n * ------\n * Nick Rabinowitz - For creating quantize.js.\n * John Schulz - For clean up and optimization. @JFSIII\n * Nathan Spady - For adding drag and drop support to the demo page.\n *\n * License\n * -------\n * Copyright Lokesh Dhakar\n * Released under the MIT license\n * https://raw.githubusercontent.com/lokesh/color-thief/master/LICENSE\n *\n * @license\n */\n\n\n/*\n  CanvasImage Class\n  Class that wraps the html image element and canvas.\n  It also simplifies some of the canvas context manipulation\n  with a set of helper functions.\n*/\n\nvar CanvasImage = function (image) {\n    this.canvas  = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n    this.width  = this.canvas.width  = image.width;\n    this.height = this.canvas.height = image.height;\n    this.context.drawImage(image, 0, 0, this.width, this.height);\n};\n\nCanvasImage.prototype.getImageData = function () {\n    return this.context.getImageData(0, 0, this.width, this.height);\n};\n\nvar ColorThief = function () {};\n\n/*\n * getColor(sourceImage[, quality])\n * returns {r: num, g: num, b: num}\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar\n * colors and return the base color from the largest cluster.\n *\n * Quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster a color will be returned but the greater the likelihood that it will not be the visually\n * most dominant color.\n *\n * */\nColorThief.prototype.getColor = function(sourceImage, quality = 10) {\n    var palette       = this.getPalette(sourceImage, 5, quality);\n    var dominantColor = palette[0];\n    return dominantColor;\n};\n\n\n/*\n * getPalette(sourceImage[, colorCount, quality])\n * returns array[ {r: num, g: num, b: num}, {r: num, g: num, b: num}, ...]\n *\n * Use the median cut algorithm provided by quantize.js to cluster similar colors.\n *\n * colorCount determines the size of the palette; the number of colors returned. If not set, it\n * defaults to 10.\n *\n * BUGGY: Function does not always return the requested amount of colors. It can be +/- 2.\n *\n * quality is an optional argument. It needs to be an integer. 1 is the highest quality settings.\n * 10 is the default. There is a trade-off between quality and speed. The bigger the number, the\n * faster the palette generation but the greater the likelihood that colors will be missed.\n *\n *\n */\nColorThief.prototype.getPalette = function(sourceImage, colorCount, quality) {\n    const options = core.validateOptions({\n        colorCount,\n        quality\n    });\n\n    // Create custom CanvasImage object\n    var image      = new CanvasImage(sourceImage);\n    var imageData  = image.getImageData();\n    var pixels     = imageData.data;\n    var pixelCount = image.width * image.height;\n\n    const pixelArray = core.createPixelArray(imageData.data, pixelCount, options.quality);\n\n    // Send array to quantize function which clusters values\n    // using median cut algorithm\n    var cmap    = quantize(pixelArray, options.colorCount);\n    var palette = cmap? cmap.palette() : null;\n\n    return palette;\n};\n\nColorThief.prototype.getColorFromUrl = function(imageUrl, callback, quality) {\n    let sourceImage = document.createElement(\"img\");\n    var thief = this;\n    sourceImage.addEventListener('load' , function(){\n        var palette = thief.getPalette(sourceImage, 5, quality);\n        var dominantColor = palette[0];\n        callback(dominantColor, imageUrl);\n    });\n    sourceImage.src = imageUrl\n};\n\n\nColorThief.prototype.getImageData = function(imageUrl, callback) {\n    let xhr = new XMLHttpRequest();\n    xhr.open('GET', imageUrl, true);\n    xhr.responseType = 'arraybuffer'\n    xhr.onload = function() {\n        if (this.status == 200) {\n            let uInt8Array = new Uint8Array(this.response)\n            i = uInt8Array.length\n            let binaryString = new Array(i);\n            for (var i = 0; i < uInt8Array.length; i++){\n                binaryString[i] = String.fromCharCode(uInt8Array[i])\n            }\n            let data = binaryString.join('')\n            let base64 = window.btoa(data)\n            callback (\"data:image/png;base64,\"+base64)\n        }\n    }\n    xhr.send();\n};\n\nColorThief.prototype.getColorAsync = function(imageUrl, callback, quality) {\n    var thief = this;\n    this.getImageData(imageUrl, function(imageData){\n        let sourceImage = document.createElement(\"img\");\n        sourceImage.addEventListener('load' , function(){\n            var palette = thief.getPalette(sourceImage, 5, quality);\n            var dominantColor = palette[0];\n            callback(dominantColor, this);\n        });\n        sourceImage.src = imageData;\n    });\n};\n\n\nexport default ColorThief;\n","function createPixelArray(imgData, pixelCount, quality) {\n    const pixels = imgData;\n    const pixelArray = [];\n\n    for (let i = 0, offset, r, g, b, a; i < pixelCount; i = i + quality) {\n        offset = i * 4;\n        r = pixels[offset + 0];\n        g = pixels[offset + 1];\n        b = pixels[offset + 2];\n        a = pixels[offset + 3];\n\n        // If pixel is mostly opaque and not white\n        if (typeof a === 'undefined' || a >= 125) {\n            if (!(r > 250 && g > 250 && b > 250)) {\n                pixelArray.push([r, g, b]);\n            }\n        }\n    }\n    return pixelArray;\n}\n\nfunction validateOptions(options) {\n    let { colorCount, quality } = options;\n\n    if (typeof colorCount === 'undefined' || !Number.isInteger(colorCount)) {\n        colorCount = 10;\n    } else if (colorCount === 1 ) {\n        throw new Error('colorCount should be between 2 and 20. To get one color, call getColor() instead of getPalette()');\n    } else {\n        colorCount = Math.max(colorCount, 2);\n        colorCount = Math.min(colorCount, 20);\n    }\n\n    if (typeof quality === 'undefined' || Number.isInteger(quality)) {\n        quality = 10;\n    } else if (quality < 1) {\n        quality = 10;\n    }\n\n    return {\n        colorCount,\n        quality\n    }\n}\n\nexport default {\n    createPixelArray,\n    validateOptions\n};\n"],"names":["pv","map","array","f","o","d","i","index","call","slice","naturalOrder","a","b","sum","reduce","p","max","Math","apply","quantize","sigbits","rshift","maxIterations","getColorIndex","r","g","PQueue","comparator","contents","sorted","sort","push","peek","undefined","length","pop","size","debug","VBox","r1","r2","g1","g2","b1","b2","histo","this","CMap","vboxes","vbox","count","volume","medianCutApply","rw","gw","maxw","copy","j","k","total","partialsum","lookaheadsum","forEach","color","left","right","vbox1","vbox2","d2","dim1","dim2","count2","min","doCut","prototype","force","_volume","_count_set","npix","_count","avg","_avg","hval","ntot","mult","rsum","gsum","bsum","contains","pixel","rval","gval","bval","palette","vb","nearest","d1","pColor","sqrt","pow","forcebw","lowest","idx","highest","pixels","maxcolors","Array","getHisto","rmin","rmax","gmin","gmax","bmin","bmax","vboxFromPixels","pq","iter","lh","target","ncolors","niters","pq2","cmap","CanvasImage","image","canvas","document","createElement","context","getContext","width","height","drawImage","getImageData","ColorThief","getColor","sourceImage","quality","getPalette","colorCount","options","Number","isInteger","Error","core","pixelArray","imgData","pixelCount","offset","data","getColorFromUrl","imageUrl","callback","thief","addEventListener","src","xhr","XMLHttpRequest","open","responseType","onload","status","uInt8Array","Uint8Array","response","binaryString","String","fromCharCode","join","base64","window","btoa","send","getColorAsync","imageData"],"mappings":"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"}