---
title: '[贪心]NOIP2012观光公交'
categories:
  - OIER
date: 2018-09-20 22:16:50
tags:
- NOIP
- 贪心
top: 5
---

[题面](https://www.luogu.org/problemnew/show/P1315)

### 做题过程

大致就是贪心，思维难度较大，实现起来细节也很多（据说网络流才是正解？）期间还碰到一个玄学问题，~~算了以后这种题还是70分水过吧~~。。

### 思路

1. 首先考虑对于每一站，有车等人和人等车两种情况
2. 然后我们发现，对于每个加速器，影响的距离是从此站到下一个车等人的站
3. 于是就瞎搞打模拟，找出每次在哪一站用受益的最多
4. 然后统计到站时间，计算答案

<!--more-->

### 源码

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
#define M 10001
#define N 1001

using namespace std;

inline int max(int a, int b) {return a > b ? a : b;}
int rn(void) {
    int t = 0, f = 1;
    char a = getchar();
    for (; a < '0' || a > '9'; a = getchar()) {if (a == '-')f = -1;}
    for (; a >= '0' && a <= '9'; a = getchar()) {t = t * 10 + a - '0';}
    return f * t;
}
struct Stop {
    int arrive_time, last_passanger_time;
    int start_time;
    int people_getout;
    int time_to_next_stop;
} S[N];
struct Passanger {
    int arrive_time;
    int stop_begin;
    int stop_end;
} P[M];

int n, m, k;

int work_time(void) {
    int rt = 0;
    for (int i = 1; i <= m; i++) {
        rt += S[P[i].stop_end].arrive_time - P[i].arrive_time;
    }
    return rt;
}

void PerSolve(void) {
    for (int i = 1; i <= n; i++) {
        S[i].arrive_time = S[i - 1].start_time + S[i - 1].time_to_next_stop;
        S[i].start_time = max (S[i].arrive_time,S[i].last_passanger_time);//启动时间一定是最晚到的乘客和到站时间之一，这里通过递推计算时间
    }
    return;
}

int main() {
    // ios::sync_with_stdio(false);
    cin >> n >> m >> k;
    for (int i = 1; i <= n - 1; i++) {
        S[i].time_to_next_stop = rn();
    }
    for (int i = 1; i <= m; i++) {
        int l, r, t;
        t = rn(), l = rn(), r = rn();
        P[i].arrive_time = t, P[i].stop_begin = l, P[i].stop_end = r;
        S[r].people_getout++;
        S[l].last_passanger_time = max(S[l].last_passanger_time, t);
    }

    PerSolve();

    while (k--) {
        int ms = 0, mp = 0, x[N]={0};
        int outs = 0;
        for(int s = n; s >= 2; s--) {//特殊处理1
            if(S[s-1].time_to_next_stop == 0) {
                if(S[s].start_time > S[s].arrive_time) {
                    outs = 0;
                }
                continue;
            }
            if(S[s].last_passanger_time >= S[s].arrive_time) outs = S[s].people_getout;
            if(S[s].last_passanger_time < S[s].arrive_time) outs += S[s].people_getout;//统计的是下车人数
            x[s] = outs;
        }
        for(int i=2;i<=n;i++){
            if(x[i] > mp) {
                ms = i - 1,mp = x[i];//一定要正序再找一遍答案，相同加速值取前面的，我也不知道为什么QAQ
            }
        }
        if(ms == 0)//特殊处理2
            break;
        S[ms].time_to_next_stop--;
        PerSolve();
    }
    cout << work_time() << endl;
    return 0;
}
```

